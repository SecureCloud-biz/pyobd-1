#!/usr/bin/env python3
# vim: shiftwidth=4:tabstop=4:expandtab
############################################################################
#
# wxgui.py
#
# Copyright 2004 Donour Sizemore (donour@uchicago.edu)
# Copyright 2009 Secons Ltd. (www.obdtester.com)
#
# This file is part of pyOBD.
#
# pyOBD is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# pyOBD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyOBD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
############################################################################

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
    
import obd_io #OBD2 funcs
import os #os.environ

import threading
import sys
import serial
import platform
import time
import configparser #safe application configuration
import webbrowser #open browser from python

from obd2_codes import pcodes
from obd2_codes import ptest

ID_ABOUT  = 101
ID_EXIT   = 110
ID_CONFIG = 500
ID_CLEAR  = 501
ID_GETC   = 502
ID_RESET  = 503
ID_LOOK   = 504
ALL_ON    = 505
ALL_OFF   = 506

ID_DISCONNECT = 507
ID_HELP_ABOUT = 508
ID_HELP_VISIT = 509
ID_HELP_ORDER = 510

#defines notification event for debug tracewindow
from debugEvent import *
       
class MyApp(QApplication):

    StatusEvent = pyqtSignal(list)
    ResultEvent = pyqtSignal(list)
    DebugEvent = pyqtSignal(int,str)
    TestEvent = pyqtSignal(list)
    DTCEvent = pyqtSignal([int],[list])

    def __init__(self, myArgs):
        QApplication.__init__(self, myArgs)
        self.OnInit()

    # A listctrl which auto-resizes the column boxes to fill
    # removed style for now
    class MyListCtrl(QTableWidget):
        def __init__(self):
            QTableWidget.__init__(self)
            self.horizontalHeader().setStretchLastSection(True)
            self.verticalHeader().hide()
            self.setSelectionBehavior(QAbstractItemView.SelectRows)
                
        def addTableRow(self, rowSize, data):
            newRow = self.rowCount()
            self.insertRow(newRow)
            for i in range(0,rowSize):
                cellData = QTableWidgetItem(data[i])
                cellData.setFlags(cellData.flags() & ~Qt.ItemIsEditable) #Make item uneditable
                self.setItem(newRow, i, cellData)

    #Add a Widget to a panel with a layout and return the Panel
    class MyPanel(QWidget):
        def __init__(self, widget):
            QWidget.__init__(self)
            layout = QVBoxLayout()
            layout.addWidget(widget)
            self.setLayout(layout)

    class sensorProducer(threading.Thread):
        def __init__(self, _notify_window,portName,baudrate,SERTIMEOUT,RECONNATTEMPTS,_nb):
            from queue import Queue
            self.portName = portName
            self.baudrate = baudrate
            self.RECONNATTEMPTS=RECONNATTEMPTS
            self.SERTIMEOUT=SERTIMEOUT 
            self.port = None
            self._notify_window=_notify_window
            self._nb=_nb
            self.active = []
            threading.Thread.__init__ ( self )
        
        def initCommunication(self):
            self.port = obd_io.OBDPort(self.portName,self.baudrate,self._notify_window,self.SERTIMEOUT,self.RECONNATTEMPTS)
            
            if self.port.State==0: #Cant open serial port
                return None
                
            self.active   = []
            self.supp     = self.port.sensor(0)[1] #read supported PIDS
            
            self.active.append(1); #PID 0 is always supported
            
            self._notify_window.ResultEvent.emit([0,0,"X"])
            self._notify_window.DebugEvent.emit(1,"Communication initialized...")
            
            for i in range(1, len(self.supp)):
                if self.supp[i-1] == "1": #put X in coloum if PID is supported
                    self.active.append(1)
                    self._notify_window.ResultEvent.emit([i,0,"X"])
                else:
                    self.active.append(0)
                    self._notify_window.ResultEvent.emit([i,0,""])
            return "OK"
        
        def run(self):
            self._notify_window.StatusEvent.emit([0,1,"Connecting...."])
            self.initCommunication()
            if self.port.State==0: #cant connect, exit thread
              self.stop()
              self._notify_window.StatusEvent.emit([666]) #signal apl, that communication was disconnected
              self._notify_window.StatusEvent.emit([0,1,"Error. Cannot connect..."])
              return None
              
            self._notify_window.StatusEvent.emit([0,1,"Connected"])
            self._notify_window.StatusEvent.emit([2,1,self.port.ELMver])
            prevstate=-1
            curstate=-1
            while self._notify_window.ThreadControl!=666:
                prevstate=curstate
                curstate=self._nb.currentIndex()
                if curstate==0: #show status tab
                  pass
                elif curstate==1: #show tests tab
                  res=self.port.get_tests_MIL()                
                  for i in range(0,len(res)):
                    self._notify_window.TestEvent.emit([i,1,res[i]])
                
                elif curstate==2: #show sensor tab
                  for i in range(3, len(self.active)):
                      if self.active[i]:
                          s = self.port.sensor(i)
                          self._notify_window.ResultEvent.emit([i,2,"%s (%s)" % (s[1], s[2])])
                      if self._notify_window.ThreadControl==666:
                          break
                elif curstate==3: #show DTC tab
                  if self._notify_window.ThreadControl == 1: #clear DTC
                      self.port.clear_dtc()

                      if self._notify_window.ThreadControl==666: #before reset ThreadControl we must check if main thread did not want us to finish
                          break
                          
                      self._notify_window.ThreadControl=0
                      prevstate=-1 # to reread DTC
                  if self._notify_window.ThreadControl == 2: #reread DTC
                      prevstate=-1
                      
                      if self._notify_window.ThreadControl==666:
                          break
                          
                      self._notify_window.ThreadControl=0
                  if prevstate!=3: 
                    self._notify_window.DTCEvent(0) #clear list
                    DTCCodes=self.port.get_dtc()
                    if len(DTCCodes)==0:
                      self._notify_window.DTCEvent.emit(["","","No DTC codes (codes cleared)"])
                    for i in range (0,len(DTCCodes)):
                      self._notify_window.DTCEvent.emit([DTCCodes[i][1],DTCCodes[i][0],pcodes[DTCCodes[i][1]]])   
                else:
                 pass 
            self.stop()

        def off(self, id):
            if id >= 0 and id < len(self.active): 
                self.active[id] = 0
            else:
                debug("Invalid sensor id")
        def on(self, id):
            if id >= 0 and id < len(self.active): 
                self.active[id] = 1
            else:
                debug("Invalid sensor id")

        def all_off(self):
            for i in range(0, len(self.active)):
                self.off(i)
        def all_on(self):
            for i in range(0, len(self.active)):
                self.off(i)
                
        def stop(self):
            if self.port != None: #if stop is called before any connection port is not defined (and not connected )
              self.port.close()
            self._notify_window.StatusEvent.emit([0,1,"Disconnected"])
            self._notify_window.StatusEvent.emit([2,1,"----"])
  
  #class producer end
        
    def sensor_control_on(self): #after connection enable few buttons
        self.configAction.setEnabled(False)
        self.connectAction.setEnabled(False)
        self.disconnectAction.setEnabled(True)
        self.getDTCAction.setEnabled(True)
        self.clearDTCAction.setEnabled(True)
        self.GetDTCButton.setEnabled(True)
        self.ClearDTCButton.setEnabled(True)

        def sensor_toggle(row, col):
            state = self.senprod.active[row]
            if   state == 0:
                self.senprod.on(sel)
                self.sensors.item(sel,1).setText("1")
            elif state == 1:
                self.senprod.off(sel)
                self.sensors.item(sel,1).setText("0")
            else:
                debug("Incorrect sensor state")
        
        self.sensors.cellClicked.connect(sensor_toggle)                

    def sensor_control_off(self): #after disconnect disable fer buttons
        self.getDTCAction.setEnabled(False)
        self.clearDTCAction.setEnabled(False)
        self.configAction.setEnabled(True)
        self.connectAction.setEnabled(True)
        self.disconnectAction.setEnabled(False)
        self.GetDTCButton.setEnabled(False)
        self.ClearDTCButton.setEnabled(False)
                
    def build_sensor_page(self):
        self.sensors = self.MyListCtrl()
        self.sensors.setColumnCount(3)
        self.sensors.setHorizontalHeaderLabels(['Supported','Sensor','Value'])
        self.sensors.setColumnWidth(0,70)
        self.sensors.setColumnWidth(1,250)
        self.sensors.horizontalHeaderItem(1).setTextAlignment(Qt.AlignRight)

        for i in range(0, len(obd_io.obd_sensors.SENSORS)):
            s = obd_io.obd_sensors.SENSORS[i].name
            self.sensors.addTableRow(3, ['', s, ''])
            self.sensors.item(i,1).setTextAlignment(Qt.AlignRight)
        
        sensorPage = self.MyPanel(self.sensors)
        self.nb.addTab(sensorPage, "Sensors")
    
    def build_DTC_page(self):
        self.DTCpanel = QWidget()
        self.GetDTCButton  = QPushButton('Get DTC')
        self.ClearDTCButton = QPushButton('Clear DTC')
        
        panelLayout = QGridLayout()
        panelLayout.addWidget(self.GetDTCButton,0,0)
        panelLayout.addWidget(self.ClearDTCButton,0,1)
        
        #bind functions to button click action
        self.GetDTCButton.clicked.connect(self.GetDTC)
        self.ClearDTCButton.clicked.connect(self.QueryClear)
        
        self.dtc = self.MyListCtrl()
                                   
        self.dtc.setColumnCount(3)
        self.dtc.setHorizontalHeaderLabels(['Code','Status','Trouble Code'])
        self.dtc.setColumnWidth(0,100)
        self.dtc.setColumnWidth(1,100)
        panelLayout.addWidget(self.dtc,1,0,1,2)
        self.DTCpanel.setLayout(panelLayout)
        
        self.nb.addTab(self.DTCpanel, "DTC")
         
    def TraceDebug(self,level,msg):
        if self.DEBUGLEVEL<=level:
            self.trace.addTableRow(2, [str(level),msg])
            
    def OnInit(self):
        self.ThreadControl = 0 #say thread what to do
        self.COMPORT = 0
        self.BAUDRATE = 0
        self.senprod = None
        self.DEBUGLEVEL = 0 #debug everthing

        def CreateMenuItem(ItemName, ToolTipText, ItemTrigger):
            menuItemAction = QAction(ItemName)
            menuItemAction.setStatusTip(ToolTipText)
            menuItemAction.triggered.connect(ItemTrigger)
            return menuItemAction
            

        #read settings from file
        self.config = configparser.RawConfigParser()
                
        #print platform.system()
        #print platform.mac_ver()[]        
        
        if "OS" in os.environ.keys(): #runnig under windows
          self.configfilepath="pyobd.ini"
        else:
          self.configfilepath=os.environ['HOME']+'/.pyobdrc'
        if self.config.read(self.configfilepath)==[]:
          self.COMPORT="/dev/ttyACM0"
          self.RECONNATTEMPTS=5
          self.SERTIMEOUT=2
          self.BAUDRATE=9600
        else:
          self.COMPORT=self.config.get("pyOBD","COMPORT")
          self.BAUDRATE=self.config.get("pyOBD","BAUDRATE")
          self.RECONNATTEMPTS=self.config.getint("pyOBD","RECONNATTEMPTS")
          self.SERTIMEOUT=self.config.getint("pyOBD","SERTIMEOUT")
        
        frame = QMainWindow()
        frame.setWindowTitle('pyOBD-II')
        self.frame=frame

        self.ResultEvent.connect(self.OnResult)
        self.DebugEvent.connect(self.OnDebug)
        self.DTCEvent.connect(self.OnDtc)
        self.StatusEvent.connect(self.OnStatus)
        self.TestEvent.connect(self.OnTests)
        
        # Main notebook frames
        
        self.nb = QTabWidget(frame)
        self.frame.setCentralWidget(self.MyPanel(self.nb))

        self.status = self.MyListCtrl()
        self.status.setColumnCount(2)
        self.status.setHorizontalHeaderLabels(['Description','Value'])
        self.status.setColumnWidth(0,100)
        self.status.addTableRow(2, ['Link State', 'Disconnected'])
        self.status.addTableRow(2, ['Protocol', '---'])
        self.status.addTableRow(2, ['Cable version', '---'])

        statusPanel  = self.MyPanel(self.status)
        self.nb.addTab(statusPanel, "Status")

        self.OBDTests = self.MyListCtrl()
        self.OBDTests.setColumnCount(2)
        self.OBDTests.setHorizontalHeaderLabels(['Description','Value'])
        self.OBDTests.setColumnWidth(0,200)

        OBDTestPanel = self.MyPanel(self.OBDTests)
        self.nb.addTab(OBDTestPanel, "Tests")
                
        for i in range(0,len(ptest)): #fill MODE 1 PID 1 test description 
            self.OBDTests.addTableRow(2, [ptest[i],'---'])
            
        self.build_sensor_page()

        self.build_DTC_page()
        
        self.trace = self.MyListCtrl()
        self.trace.setColumnCount(2)
        self.trace.setHorizontalHeaderLabels(['Level','Message'])
        self.trace.setColumnWidth(0,40)

        tracePanel = self.MyPanel(self.trace)
        self.nb.addTab(tracePanel, "Trace")

        self.TraceDebug(1,"Application started")

        self.frame.statusBar()
        
        # Creating the menubar.
        self.menuBar = self.frame.menuBar()
        self.filemenu = self.menuBar.addMenu("&File") # Adding the "filemenu" to the MenuBar
        self.settingmenu = self.menuBar.addMenu("&OBD-II")
        self.dtcmenu = self.menuBar.addMenu("&Trouble codes")
        self.helpmenu = self.menuBar.addMenu("&Help")

        # Setting up the menu.

        self.exitAction = CreateMenuItem("E&xit"," Terminate the program", self.OnExit)
        self.filemenu.addAction(self.exitAction)

        self.configAction = CreateMenuItem("Configure"," Configure pyOBD",self.Configure)
        self.connectAction = CreateMenuItem("Connect"," Reopen and connect to device",self.OpenPort)
        self.disconnectAction = CreateMenuItem("Disconnect","Close connection to device",self.OnDisconnect)
        self.settingmenu.addAction(self.configAction)
        self.settingmenu.addAction(self.connectAction)
        self.settingmenu.addAction(self.disconnectAction)

        # tady toto nastavi automaticky tab DTC a provede akci
        self.getDTCAction = CreateMenuItem("Get DTCs",   " Get DTC Codes", self.GetDTC)
        self.clearDTCAction = CreateMenuItem("Clear DTC",  " Clear DTC Codes", self.QueryClear)
        self.codeLookupAction = CreateMenuItem("Code Lookup"," Lookup DTC Codes", self.CodeLookup)
        self.dtcmenu.addAction(self.getDTCAction)
        self.dtcmenu.addAction(self.clearDTCAction)
        self.dtcmenu.addAction(self.codeLookupAction)

        
        self.aboutAction = CreateMenuItem("About this program","",self.OnHelpAbout)
        self.visitAction = CreateMenuItem("Visit program homepage","",self.OnHelpVisit)
        self.orderAction = CreateMenuItem("Order OBD-II interface","",self.OnHelpOrder)
        self.helpmenu.addAction(self.aboutAction)
        self.helpmenu.addAction(self.visitAction)
        self.helpmenu.addAction(self.orderAction)

        frame.show()
        frame.resize(520,400)
        self.sensor_control_off()

        return True

    def OnHelpVisit(self,event):
        webbrowser.open("http://www.obdtester.com/pyobd")
    
    def OnHelpOrder(self,event):
        webbrowser.open("http://www.obdtester.com/order")
    
    def OnHelpAbout(self,event): #todo about box
        Text = """<p>PyOBD is an automotive OBD2 diagnostic application that works with ELM237 cables.</p>

<p>(C) 2008-2009 SeCons Ltd.<br>
(C) 2004 Charles Donour Sizemore</p>

<p><a href='http://www.obdtester.com/'>http://www.obdtester.com/</a><br>
<a href='http://www.secons.com/'>http://www.secons.com/</a></p>

<p>PyOBD is free software; you can redistribute it and/or modify 
it under the terms of the GNU General Public License as published by the Free Software Foundation; 
either version 2 of the License, or (at your option) any later version.</p>

<p>PyOBD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with PyOBD; if not, see <a href='https://www.gnu.org/licenses/'>https://www.gnu.org/licenses/.</a></p>
"""
        HelpAboutDlg = QMessageBox(QMessageBox.Information, 'About', Text, QMessageBox.Ok, self.frame)
        HelpAboutDlg.setTextFormat(Qt.RichText)
        HelpAboutDlg.exec()

    def OnResult(self,event):
        self.sensors.addTableRow(3, event)
    
    def OnStatus(self,event):
        if event[0] == 666: #signal, that connection falied
            self.sensor_control_off()
        else:
            self.status.item(event[0],event[1]).setText(event[2])
    
    def OnTests(self,event):
        self.OBDTests.addTableRow(3, event)
         
    def OnDebug(self, level, msg):    
        self.TraceDebug(level, msg)
    
    def OnDtc(self,event):
        if event == 0: #signal, that DTC was cleared
            self.dtc.clearContents()
        else:
            self.dtc.addTableRow(len(event), event.data)
    
    def OnDisconnect(self,event): #disconnect connection to ECU
        self.ThreadControl=666
        self.sensor_control_off()
        
    def OpenPort(self,e):
        
        if self.senprod: # signal current producers to finish
            self.senprod.stop()
        self.ThreadControl = 0    
        self.senprod = self.sensorProducer(self,self.COMPORT,self.BAUDRATE, self.SERTIMEOUT,self.RECONNATTEMPTS,self.nb)
        self.senprod.start() 
        
        self.sensor_control_on()
        
    def GetDTC(self,e):
        self.nb.setCurrentWidget(self.DTCPanel)
        self.ThreadControl=2
        
    def AddDTC(self, code):
        self.dtc.addTableRow(2, code)


    def CodeLookup(self,e = None):
        id = 0
        diag = QDialog(self.frame)
        diag.setWindowTitle('Diagnostic Trouble Codes')

        tree = QTreeWidget(diag)

        root = QTreeWidgetItem(tree)
        root.setText(0,"Code Reference")
        proot = root; # tree.AppendItem(root,"Powertrain (P) Codes")
        codes = sorted(pcodes.keys())
        group = ''
        for c in codes:
            if c[:3] != group:
                group_root = QTreeWidgetItem(proot)
                group_root.setText(0,c[:3]+"XX")
                proot.addChild(group_root)
                group = c[:3]
            leaf = QTreeWidgetItem(group_root)
            leaf.setText(0,c)
            group_root.addChild(leaf)
            codeText = QTreeWidgetItem(leaf)
            codeText.setText(0,pcodes[c])
            leaf.addChild(codeText)

        layout = QHBoxLayout(diag)
        layout.addWidget(tree)
        tree.header().hide()
        diag.setLayout(layout)
        diag.resize(400,500)
        diag.show()

        
    def QueryClear(self,e):
        id = 0
        diag = QMessageBox(QMessageBox.Question, 'Clear DTC?', \
                                     'Are you sure you wish to clear all DTC codes and freeze frame data?',\
                                     QMessageBox.Yes | QMessageBox.No, self.frame)

        r  = diag.exec()
        if r == QMessageBox.Yes:
            self.ClearDTC()

    def ClearDTC(self):
        self.ThreadControl=1
        self.nb.setCurrentWidget(self.DTCPanel.parentWidget())
        
    
    def scanSerial(self):
        #Scan for available ports. Return a list of serial names
        available = []
        for i in range(256):
          try: #scan Windows COM*
            s = serial.Serial("COM" + str(i))
            available.append(s.portstr)
            s.close()   # explicit close 'cause of delayed GC in java
          except serial.SerialException:
            pass
        for i in range(256):
          try: #scan standart ttyS*
            s = serial.Serial("/dev/ttyS" + str(i))
            available.append(s.portstr)
            s.close()   # explicit close 'cause of delayed GC in java
          except serial.SerialException:
            pass
        for i in range(256):
          try: #scan USB ttyACM
            s = serial.Serial("/dev/ttyACM"+str(i))
            available.append(s.portstr)
            s.close()   # explicit close 'cause of delayed GC in java
          except serial.SerialException:
            pass
        for i in range(256):
          try:
            s = serial.Serial("/dev/ttyUSB"+str(i))
            available.append(s.portstr)
            s.close()   # explicit close 'cause of delayed GC in java
          except serial.SerialException:
            pass
        for i in range(256):
          try:
            s = serial.Serial("/dev/ttyd"+str(i))
            available.append(s.portstr)
            s.close()   # explicit close 'cause of delayed GC in java
          except serial.SerialException:
            pass
            
        # ELM-USB shows up as /dev/tty.usbmodemXXXX, where XXXX is a changing hex string
        # on connection; so we have to search through all 64K options
        if len(platform.mac_ver()[0])!=0:  #search only on MAC
          for i in range (65535):
            extension = hex(i).replace("0x","", 1)
            try:
              s = serial.Serial("/dev/tty.usbmodem"+extension)
              available.append(s.portstr)
              s.close()
            except serial.SerialException:
              pass 
        
        return available

    def Configure(self,e = None):
        id = 0
        diag = QDialog(self.frame)
        diag.setWindowTitle("Configure")
        sizer = QFormLayout()
        
        ports = self.scanSerial()
        comportDropdown = QComboBox()
        comportDropdown.addItems(ports)
        sizer.addRow('Choose Serial Port: ', comportDropdown)

        #baudrates = ['9600', '19200', '28800', '38400', '48000', '115200']
        baudrates = [ ]
        baudrateDropdown = QComboBox()
        baudrateDropdown.addItems(baudrates)
        sizer.addRow('Choose Baud Rate: ', baudrateDropdown)

        #timeOut input control                
        timeoutCtrl = QLineEdit(str(self.SERTIMEOUT))
        sizer.addRow('Timeout:', timeoutCtrl)
        
        #reconnect attempt input control                
        reconnectCtrl = QLineEdit(str(self.RECONNATTEMPTS))
        sizer.addRow('Reconnect attempts:', reconnectCtrl)
               
        #set actual serial port choice
        if (self.COMPORT != 0) and (self.COMPORT in ports):
          comportDropdown.setCurrentIndex(ports.index(self.COMPORT))
        else:
          comportDropdown.setCurrentIndex(0)

        if comportDropdown.currentIndex() >= 0:
            for rate in serial.Serial(ports[comportDropdown.currentIndex()]).BAUDRATES:
                if rate >=9600 and rate <=115200:
                    baudrates.append(str(rate))

            baudrateDropdown.addItems(baudrates)

            if (self.BAUDRATE != 0) and (self.BAUDRATE in baudrates):
                baudrateDropdown.setCurrentIndex(baudrates.index(self.BAUDRATE))
            else:
                baudrateDropdown.setCurrentIndex(baudrates.index('38400'))
        
        okButton = QPushButton('OK')
        cancelButton = QPushButton('Cancel')
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(okButton)
        buttonLayout.addWidget(cancelButton)
        okButton.clicked.connect(diag.accept)
        cancelButton.clicked.connect(diag.reject)
        sizer.addRow(buttonLayout)
        diag.setLayout(sizer)

        r  = diag.exec()

        if r == QDialog.Accepted and comportDropdown.currentIndex() >=0 and baudrateDropdown.currentIndex() >=0:
            
            #create section
            if self.config.sections()==[]:
              self.config.add_section("pyOBD")
            #set and save COMPORT
            self.COMPORT = ports[comportDropdown.currentIndex()]
            self.config.set("pyOBD","COMPORT",self.COMPORT)

            self.BAUDRATE = baudrates[baudrateDropdown.currentIndex()]
            self.config.set("pyOBD","BAUDRATE",self.BAUDRATE)			
            
            #set and save SERTIMEOUT
            self.SERTIMEOUT = int(timeoutCtrl.text())
            self.config.set("pyOBD","SERTIMEOUT",self.SERTIMEOUT)
            self.status.item(3,1).setText(self.COMPORT); 
            
            #set and save RECONNATTEMPTS
            self.RECONNATTEMPTS = int(reconnectCtrl.text())
            self.config.set("pyOBD","RECONNATTEMPTS",self.RECONNATTEMPTS)
            
            #write configuration to cfg file
            self.config.write(open(self.configfilepath, 'w'))

    def OnExit(self,e = None):
        import sys
        sys.exit(0)

app = MyApp(sys.argv)
sys.exit(app.exec_())
